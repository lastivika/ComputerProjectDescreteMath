# README по виконанню проекту: Бібліотека для роботи з графами 
# Мета проєкту
- Створити бібліотеку, яка вміє читати графи з файлів.
- Надати реалізації базових та класичних алгоритмів теорії графів.
  
# Розподіл роботи
#### Даніїл Доган: 
* читання графа з файлу CSV
* створення структури графа
#### Cеверин Сливка:
* алгоритм пошуку гамільтонового циклу
#### Ярослав Коваль:
* алгоритм пошуку ейлерового циклу
#### Юлія Олійник:
* алгоритм перевірки двочастковості графа
* реалізація 3-розфарбування графа
* написання звіту
#### Максим Киба:
* перевірка двох графів на ізоморфізм

# Читання графу з CSV файлу та створення структури графа
  Коректне завантаження вхідних даних та формування внутрішнього подання графа - один із найважливіших етапів роботи з графами. Ключове завдання описаного модуля - отримання графу з файлу, перевірка на валідність даних, побудова матриці суміжності, яка надалі використовується всіма алгоритмами бібліотеки. CSV-файл повинен містити рівно дві колонки: перша — початкова вершина ребра, друга — кінцева вершина. Функція підтримує як орієнтовані, так і неорієнтовані графи.
  Без цього модуля жодна наступна функція в бібліотеці не працюватиме, так як модуль забезпечує уявлення графа. Незначна помилка у вхідних даних - і результати вже некоректні, тож модуль забезпечує цілісність та коректність усієї обчислювальної логіки проєкту.

# Алгоритм пошуку гамільтонового циклу
  Гамільтоновий цикл - це цикл у графі, який проходить кожною вершиною рівно один раз і повертається в початкову вершину. 
  ### Як працює алгоритм пошуку:
1. Починаємо з першої вершини.
2. Поступово додаємо шлях, додаючи вершини одну за одною (перед тим перевіряємо чи існує вершина і чи вона вже ще не додана).
3. Якщо шлях неможливо продовжувати - повертаємось на минулу вершину і пробуємо взяти іншою наступну вершину.
4. Коли шлях закінчено - перевіряється чи вершина на якій ми знаходимося є перед нашою стартовою.
   ### В коді реалізовано:
- функцію для перевірки чи можна додати вершину.
- рекурсивну функцію, яка реалізовує backtracking тоді, коли вершина нам не підходить.
- функцію, яка шукає гамільтоновий цикл.

# Алгоритм пошуку ейлерового циклу (Використаний алгоритм Флері)
  Ейлеровий цикл - це цикл у графі, який проходить кожним ребром рівно один раз і повертається в початкову вершину.
  ### Чому алгоритм Флері?
Алгоритм Флері - класичний метод побудови ейлерового циклу. Суть алгоритму: рухатись по доступних ребрах, уникати "мостів" у графах.
  ### Як працює алгоритм пошуку:
1. Перевірка чи є граф звʼязний та чи є ребро мостом.
2. Сторює копію графа, видаляє якесь ребро, потім алгоритмом пошуку вглиб (DFS) перевіряє чи якась вершина стала неосяжною - якщо так, то це ребро було мостом.
3. Перевірка чи вершини в графі мають парних степінь.
4. Будуємо ейлеровий цикл.
  ### Недоліки:
На великих графах алгоритм буде повільно працювати.
  
# Алгоритм перевірки графа на двочастковість
  Граф називається двочастковим, якщо всі його вершини можна розбити на дві множини так, що:
- жодні дві вершини у межах однієї множини не з’єднані ребром
- кожне ребро сполучає вершини з різних множин.
_Граф є двочастковим тоді й тільки тоді, коли він не містить непарних циклів._
   ### Як працює алгоритм перевірки:
1. Обходимо граф за шириною (BFS), кожній вершині присвоюємо 1 або -1 (як кольори).
2. Якщо при обході виявляється, що сусідня вершина має той самий колір, граф не двочастковий.
3. Якщо граф при обході успішно розфарбовується - він двочастковий.
   ### В коді реалізовано:
- ініціалізацію кольорів.
- внутрішня функція BFS.
- перевірка всіх компонент звʼязності.

# Розфарбовування графа в 3 кольори
  Реалізація алгоритму розфарбовування графа у три кольори з використанням рекурсивного пошуку з поверненням назад (backtracking). Призначає кожній вершині один із трьох кольорів так, щоб суміжні вершини не мали однакового кольору.
  ### Як працює алгоритм розфарбовування:
1. Зчитування матриці сумжності.
2. Перетворення в список суміжності для зручності.
3. Присвоєння кольору відбувається після перевірки чи сусіди не мають такий же колір.
4. Якщо не виходить розфарбувати в три кольори так, щоб суміжні вершини мали різні кольори - використовується backtracking.
  ### Як виглядає візуалізація:
Візуалізація розфарбовки графа на прикладі
graph = [
        [1, 2, 5],
        [0, 2, 3],
        [0, 1, 4],
        [1, 4, 5],
        [2, 3, 5],
        [0, 3, 4]
    ]

<img width="799" height="599" alt="graph CPDM" src="https://github.com/user-attachments/assets/ee40666e-0b41-4494-bcd2-5d52e74eb9b2" />

# Перевірка двох графів на ізоморфізм
